\documentclass{td}

\usepackage{src/sty/config}

\codeUE{XLG4IU020}
\intituleUE{Programmation Concurrente en Multi-Threads}
\cursus{M1 ALMA \& Smart Computing}

\author{Matthieu \textsc{Perrin}}

\logo{src/img/logoUN.png}
\institution{Nantes Université}

\typeTP[2]
\title{Recherche récursive d'expressions régulières sur le Web}

\hypersetup{
  pdftitle  = {TP 2 - Recherche récursive d'expressions régulières sur le Web},
  pdfauthor = {Matthieu Perrin},
  pdfsubject  = {TP de M1 du cours Programmation Concurrente en Multi-Threads},
  pdfkeywords = {concurrence, Java, modèle de mémoire, moniteur, parallélisme, sûreté, thread, verrou, vivacité}
}

\begin{document}

\maketitle

Pour pouvoir répondre efficacement aux requêtes des utilisateurs,
les moteurs de recherche comme Google maintiennent un index de l'ensemble des pages du Web,
accompagné de la liste des mots qu'elles contiennent.
Cet index est construit grâce à des \emph{robots d'indexation}
(en anglais \emph{web crawlers})
qui explorent automatiquement les pages du Web en suivant leurs hyperliens.

Le but de ce projet est d'implémenter un mini-robot d'indexation
capable de rechercher des \emph{expressions régulières} sur le Web.
Par exemple, la commande suivante doit rechercher toutes les pages contenant le mot \og{}Nantes\fg{},
accessibles depuis la page Wikipédia de la ville :

\begin{lstlisting}
$ java WebGrep Nantes https://fr.wikipedia.org/wiki/Nantes
https://fr.wikipedia.org/wiki/Nantes
https://fr.wikiquote.org/wiki/Nantes
https://fr.wiktionary.org/wiki/Nantes
https://fr.wikivoyage.org/wiki/Nantes
...
\end{lstlisting}

\paragraph{Algorithme à implémenter.}

Pour obtenir les résultats, on commencera par chercher une occurrence de l'expression dans la page donnée en argument.
Si la page contient l'expression, on continuera la recherche en suivant tous les liens de la page, récursivement.
Le temps de recherche étant largement dominé par les accès réseau, on souhaite accélérer l'exploration
en \emph{parallélisant} le programme.  
Le but du TP est donc de concevoir une architecture parallèle efficace.

Une classe \lstinline{Tools} est fournie en Java pour effectuer les tâches séquentielles.
Elle contient principalement les méthodes statiques suivantes :

\begin{description}
  \item[\texttt{Tools.initialize(args)}] analyse les arguments du programme pour extraire l'expression régulière, les URL de départ et les options d'affichage.  
  La liste complète des options peut être affichée avec \texttt{Tools.initialize("--help")}.  
  Après initialisation, la liste des URL de départ est accessible via \texttt{Tools.startingURL()}  
  et le nombre de threads à créer via \texttt{Tools.numberThreads()}.

  \item[\texttt{Tools.parsePage(address)}] télécharge et analyse la page HTML à l'adresse indiquée,  
  puis retourne un objet \texttt{ParsedPage} donnant accès à la liste des liens hypertextes  
  (\texttt{page.hrefs()}) et à la liste des éléments HTML contenant l'expression régulière recherchée  
  (\texttt{page.matches()}).

  \item[\texttt{Tools.print(page)}] produit un affichage textuel de la \texttt{ParsedPage} passée en argument,
  en respectant les options d'affichage configurées lors de l'initialisation de \texttt{Tools}.
\end{description}

\medskip
\noindent
\textbf{Remarque :} le pare-feu des salles de TP bloque l'accès à Internet pour les requêtes automatiques.
L'option \lstinline{-O} (ou \lstinline{--offline}) permet de travailler en mode local :
les pages sont alors générées de manière déterministe, à partir d'exemples fournis avec le code source Java.

\paragraph{Architecture parallèle.}

L'architecture parallèle du programme doit respecter les contraintes suivantes :

\begin{enumerate}
  \item \textbf{Parallélisation :}
  la recherche doit être répartie entre $n = \texttt{Tools.numberThreads()}$ threads.
  On créera un \emph{pool} de $n$ threads, auquel on soumettra une tâche pour chaque page à explorer.

  \item \textbf{Exploration unique :}
  une même URL ne doit jamais être explorée deux fois.
  On conservera en mémoire la liste (ou l'ensemble) des pages déjà visitées.
  La vérification qu'une page n'y figure pas et son insertion doivent être effectuées dans un même bloc atomique
  (pourquoi ?).  
  On pourra pour cela utiliser la classe \texttt{ConcurrentSkipListSet} et, en particulier, sa méthode \texttt{add}.

  \item \textbf{Sortie cohérente :}
  il ne faut pas d'entrelacement entre les sorties de deux threads.
  La méthode statique \texttt{Tools.print} fournie n'est pas thread-safe.
  On suggère de dédier un thread unique aux sorties textuelles, selon le modèle \emph{producteur–consommateur} :
  les producteurs sont les threads du pool, qui produisent des objets \texttt{ParsedPage},
  et le consommateur est un thread séparé chargé de l'affichage.
\end{enumerate}

\end{document}
